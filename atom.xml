<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Now X Blog]]></title>
  <link href="http://forhappy.github.io/atom.xml" rel="self"/>
  <link href="http://forhappy.github.io/"/>
  <updated>2015-07-15T12:49:50+08:00</updated>
  <id>http://forhappy.github.io/</id>
  <author>
    <name><![CDATA[forhappy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to C++11 Thread]]></title>
    <link href="http://forhappy.github.io/blog/2015/05/16/introduction-to-c-plus-plus-11-thread/"/>
    <updated>2015-05-16T22:47:30+08:00</updated>
    <id>http://forhappy.github.io/blog/2015/05/16/introduction-to-c-plus-plus-11-thread</id>
    <content type="html"><![CDATA[<p>本节将详细介绍 <code>std::thread</code> 的用法。</p>

<p><code>std::thread</code> 在 <code>&lt;thread&gt;</code> 头文件中声明，因此使用 <code>std::thread</code> 需包含 <code>&lt;thread&gt;</code> 头文件。</p>

<!-- more -->


<h2><code>&lt;thread&gt;</code> 头文件摘要</h2>

<p><code>&lt;thread&gt;</code> 头文件声明了 std::thread 线程类及 <code>std::swap</code> (交换两个线程对象)辅助函数。另外命名空间 <code>std::this_thread</code> 也声明在 <code>&lt;thread&gt;</code> 头文件中。下面是 C++11 标准所定义的 <code>&lt;thread&gt;</code> 头文件摘要：</p>

<blockquote><p>参见 N3242=11-0012 草案第 30.3 节 Threads(p1133)。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'>    <span class="cp">#define __STDCPP_THREADS__ __cplusplus</span>
</span><span class='line'>    <span class="n">class</span> <span class="kr">thread</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="n">namespace</span> <span class="n">this_thread</span> <span class="p">{</span>
</span><span class='line'>        <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">get_id</span><span class="p">();</span>
</span><span class='line'>        <span class="kt">void</span> <span class="nf">yield</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Clock</span><span class="p">,</span> <span class="n">class</span> <span class="n">Duration</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="kt">void</span> <span class="n">sleep_until</span><span class="p">(</span><span class="k">const</span> <span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Duration</span><span class="o">&gt;&amp;</span> <span class="n">abs_time</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">class</span> <span class="n">Period</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="kt">void</span> <span class="n">sleep_for</span><span class="p">(</span><span class="k">const</span> <span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Rep</span><span class="p">,</span> <span class="n">Period</span><span class="o">&gt;&amp;</span> <span class="n">rel_time</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>&lt;thread&gt;</code> 头文件主要声明了 <code>std::thread</code> 类，另外在 <code>std::this_thread</code> 命名空间中声明了 <code>get_id</code>，<code>yield</code>，<code>sleep_until</code> 以及 <code>sleep_for</code> 等辅助函数，本章稍微会详细介绍 <code>std::thread</code> 类及相关函数。</p>

<h3><code>std::thread</code> 类摘要</h3>

<p><code>std::thread</code> 代表了一个线程对象，C++11 标准声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">class</span> <span class="kr">thread</span> <span class="p">{</span>
</span><span class='line'>        <span class="nl">public</span><span class="p">:</span>
</span><span class='line'>            <span class="c1">// 类型声明:</span>
</span><span class='line'>            <span class="n">class</span> <span class="n">id</span><span class="p">;</span>
</span><span class='line'>            <span class="k">typedef</span> <span class="n">implementation</span><span class="o">-</span><span class="n">defined</span> <span class="n">native_handle_type</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 构造函数、拷贝构造函数和析构函数声明:</span>
</span><span class='line'>            <span class="kr">thread</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>            <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">F</span><span class="p">,</span> <span class="n">class</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span> <span class="n">explicit</span> <span class="kr">thread</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</span><span class='line'>            <span class="o">~</span><span class="kr">thread</span><span class="p">();</span>
</span><span class='line'>            <span class="kr">thread</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
</span><span class='line'>            <span class="kr">thread</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>            <span class="kr">thread</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
</span><span class='line'>            <span class="kr">thread</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 成员函数声明:</span>
</span><span class='line'>            <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">bool</span> <span class="n">joinable</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">void</span> <span class="nf">join</span><span class="p">();</span>
</span><span class='line'>            <span class="kt">void</span> <span class="nf">detach</span><span class="p">();</span>
</span><span class='line'>            <span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>            <span class="n">native_handle_type</span> <span class="nf">native_handle</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 静态成员函数声明:</span>
</span><span class='line'>            <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">hardware_concurrency</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>std::thread</code> 中主要声明三类函数：(1). 构造函数、拷贝构造函数及析构函数；(2). 成员函数；(3). 静态成员函数。另外， <code>std::thread::id</code> 表示线程 ID，同时 C++11 声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">class</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="p">{</span>
</span><span class='line'>        <span class="nl">public</span><span class="p">:</span>
</span><span class='line'>            <span class="n">id</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">y</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">operator</span><span class="o">!=</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">y</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">y</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">y</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">y</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">x</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">y</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">charT</span><span class="p">,</span> <span class="n">class</span> <span class="n">traits</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">basic_ostream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span>
</span><span class='line'>        <span class="n">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">basic_ostream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">id</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Hash 支持</span>
</span><span class='line'>    <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">hash</span><span class="p">;</span>
</span><span class='line'>    <span class="n">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="o">&gt;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><code>std::thread</code> 详解</h2>

<h3><code>std::thread</code> 构造和赋值</h3>

<h4><code>std::thread</code> 构造函数</h4>

<table>
<tbody>
<tr class="odd"><th>默认构造函数 (1)</th>
<td>thread() noexcept;</td>
</tr>
<tr class="even"><th>初始化构造函数 (2)</th>
<td>
template &lt;class Fn, class... Args&gt;<br/>
explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;... args);
</td>
</tr>
<tr class="odd"><th>拷贝构造函数 [deleted] (3)</th>
<td>
thread(const thread&amp;) = delete;
</td>
</tr>
<tr class="even"><th>Move 构造函数 (4)</th>
<td>
thread(thread&amp;&amp; x) noexcept;
</td>
</tr>
</tbody>
</table>


<ol>
<li>默认构造函数(1)，创建一个空的 <code>std::thread</code> 执行对象。</li>
<li>初始化构造函数(2)，创建一个 <code>std::thread</code> 对象，该 <code>std::thread</code> 对象可被 <code>joinable</code>，新产生的线程会调用 <code>fn</code> 函数，该函数的参数由 <code>args</code> 给出。</li>
<li>拷贝构造函数(被禁用)(3)，意味着 <code>std::thread</code> 对象不可拷贝构造。</li>
<li>Move 构造函数(4)，move 构造函数(move 语义是 C++11 新出现的概念，详见附录)，调用成功之后 <code>x</code> 不代表任何 <code>std::thread</code> 执行对象。</li>
</ol>


<blockquote><p>注意：可被 <code>joinable</code> 的 <code>std::thread</code> 对象必须在他们销毁之前被主线程 <code>join</code> 或者将其设置为 <code>detached</code>.</p></blockquote>

<p>std::thread 各种构造函数例子如下（<a href="http://en.cppreference.com/w/cpp/thread/thread/thread">参考</a>）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;atomic&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Thread &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; executing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Thread 2 executing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">// t1 is not a thread</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// pass by value</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="c1">// pass by reference</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t3</span><span class="p">));</span> <span class="c1">// t4 is now running f2(). t3 is no longer a thread</span>
</span><span class='line'>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Final value of n is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4><code>std::thread</code> 赋值操作</h4>

<table style="width: 475px; height: 87px;">
<tbody>
<tr class="odd"><th>Move 赋值操作 (1)</th>
<td>
thread&amp; operator=(thread&amp;&amp; rhs) noexcept;
</td>
</tr>
<tr class="even"><th>拷贝赋值操作 [deleted] (2)</th>
<td>
thread&amp; operator=(const thread&amp;) = delete;
</td>
</tr>
</tbody>
</table>


<ol>
<li>Move 赋值操作(1)，如果当前对象不可 <code>joinable</code>，需要传递一个右值引用(<code>rhs</code>)给 <code>move</code> 赋值操作；如果当前对象可被 <code>joinable</code>，则会调用 <code>terminate</code>() 报错。</li>
<li>拷贝赋值操作(2)，被禁用，因此 <code>std::thread</code> 对象不可拷贝赋值。</li>
</ol>


<p>请看下面的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;    </span><span class="c1">// std::chrono::seconds</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;  </span><span class="c1">// std::cout</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;    </span><span class="c1">// std::thread, std::this_thread::sleep_for</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">thread_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;hello thread &quot;</span>
</span><span class='line'>        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span>
</span><span class='line'>        <span class="o">&lt;&lt;</span> <span class="s">&quot; paused &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; seconds&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Spawning 5 threads...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Done spawning threads! Now wait for them to join</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span><span class="p">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;All threads joined.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>其他成员函数</h3>

<blockquote><p>本小节例子来自 <a href="http://en.cppreference.com/w/cpp/thread/thread">http://en.cppreference.com </a></p></blockquote>

<ul>
<li><code>get_id</code>: 获取线程 ID，返回一个类型为 <code>std::thread::id</code> 的对象。请看下面例子：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">t1_id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">get_id</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">t2_id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">get_id</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;t1&#39;s id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t1_id</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;t2&#39;s id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t2_id</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>joinable</code>: 检查线程是否可被 join。检查当前的线程对象是否表示了一个活动的执行线程，由默认构造函数创建的线程是不能被 join 的。另外，如果某个线程 已经执行完任务，但是没有被 join 的话，该线程依然会被认为是一个活动的执行线程，因此也是可以被 join 的。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;before starting, joinable: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;after starting, joinable: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>join</code>: Join 线程，调用该函数会阻塞当前线程，直到由 <code>*this</code> 所标示的线程执行完毕 join 才返回。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// simulate expensive operation</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// simulate expensive operation</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;starting first helper...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">helper1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;starting second helper...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">helper2</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;waiting for helpers to finish...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">helper1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">helper2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;done!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>detach</code>: Detach 线程。
将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放。</li>
</ul>


<p>调用 detach 函数之后：</p>

<ol>
<li><code>*this</code> 不再代表任何的线程执行实例。</li>
<li>joinable() == false</li>
<li>get_id() == std::thread::id()</li>
</ol>


<p>另外，如果出错或者 <code>joinable() == false</code>，则会抛出 <code>std::system_error</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">independentThread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Starting concurrent thread.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exiting concurrent thread.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">threadCaller</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Starting thread caller.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">independentThread</span><span class="p">);</span>
</span><span class='line'>    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exiting thread caller.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">threadCaller</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>swap</code>: Swap 线程，交换两个线程对象所代表的底层句柄(underlying handles)。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread 1 id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t1</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread 2 id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;after std::swap(t1, t2):&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread 1 id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t1</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread 2 id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;after t1.swap(t2):&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread 1 id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t1</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread 2 id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果如下：</p>

<pre><code>thread 1 id: 1892
thread 2 id: 2584
after std::swap(t1, t2):
thread 1 id: 2584
thread 2 id: 1892
after t1.swap(t2):
thread 1 id: 1892
thread 2 id: 2584
</code></pre>

<ul>
<li><code>native_handle</code>: 返回 native handle（由于 <code>std::thread</code> 的实现和操作系统相关，因此该函数返回与 <code>std::thread</code> 具体实现相关的线程句柄，例如在符合 Posix 标准的平台下(如 Unix/Linux)是 Pthread 库）。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstring&gt;</span>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">iomutex</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">sched_param</span> <span class="n">sch</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">policy</span><span class="p">;</span>
</span><span class='line'>   <span class="n">pthread_getschedparam</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">policy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sch</span><span class="p">);</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iomutex</span><span class="p">);</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Thread &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; is executing at priority &quot;</span>
</span><span class='line'>             <span class="o">&lt;&lt;</span> <span class="n">sch</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">t2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sched_param</span> <span class="n">sch</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">policy</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pthread_getschedparam</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">native_handle</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">policy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sch</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sch</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">pthread_setschedparam</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">native_handle</span><span class="p">(),</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sch</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Failed to setschedparam: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果如下：</p>

<pre><code>Thread 2 is executing at priority 0
Thread 1 is executing at priority 20
</code></pre>

<ul>
<li><code>hardware_concurrency</code> [static]: 检测硬件并发特性，返回当前平台的线程实现所支持的线程并发数目，但返回值仅仅只作为系统提示(hint)。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; concurrent threads are supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><code>std::this_thread</code> 命名空间中相关辅助函数介绍</h2>

<ul>
<li>get_id: 获取线程 ID。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;mutex&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">g_display_mutex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">this_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">g_display_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;thread &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this_id</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; sleeping...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">g_display_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>yield: 当前线程放弃执行，操作系统调度另一线程继续执行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// &quot;busy sleep&quot; while suggesting that other threads run </span>
</span><span class='line'><span class="c1">// for a small amount of time</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">little_sleep</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span> <span class="n">us</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">us</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">little_sleep</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">auto</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;waited for &quot;</span>
</span><span class='line'>              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elapsed</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
</span><span class='line'>              <span class="o">&lt;&lt;</span> <span class="s">&quot; microseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>sleep_until: 线程休眠至某个指定的时刻(time point)，该线程才被重新唤醒。</p>

<pre><code>  template&lt; class Clock, class Duration &gt;
  void sleep_until( const std::chrono::time_point&lt;Clock,Duration&gt;&amp; sleep_time );
</code></pre></li>
<li><p>sleep_for: 线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠时间可能比 <code>sleep_duration</code> 所表示的时间片更长。</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">template</span><span class="o">&lt;</span> <span class="n">class</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">class</span> <span class="n">Period</span> <span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">sleep_for</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Rep</span><span class="p">,</span><span class="n">Period</span><span class="o">&gt;&amp;</span> <span class="n">sleep_duration</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello waiter&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span> <span class="mi">2000</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span> <span class="n">dura</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Waited 2000 ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果如下：</p>

<pre><code>Hello waiter
Waited 2000 ms
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 Concurrency Introduction]]></title>
    <link href="http://forhappy.github.io/blog/2015/05/16/c-plus-plus-11-concurrency-introduction/"/>
    <updated>2015-05-16T22:35:38+08:00</updated>
    <id>http://forhappy.github.io/blog/2015/05/16/c-plus-plus-11-concurrency-introduction</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>C++11 是 2011 年 9 月 1 号发布的。C++11 在 C++03 的基础上做了大量的改进，引入了很多新的特性，比如 Lambda 表达式，右值引用，统一的列表初始化方式，正则表达式等等。当然，其中最令人激动的特性是新标准引入了原子操作类和线程支持库。C++ 一直在语言层面缺少对多线程的支持，因此 C++11 新标准基本上弥补了这一缺陷。可以毫不夸张地说，C++11 相当于一门新的编程语言。</p>

<p>相信 Linux 程序员都用过 Pthread, 但有了 C++11 的 std::thread 以后，你可以在语言层面编写多线程程序了，直接的好处就是多线程程序的可移植性得到了很大的提高，所以作为一名 C++ 程序员，熟悉 C++11 的多线程编程方式还是很有益处的。</p>

<p>如果你对 C++11 不太熟悉，建议先看看维基百科上关于 C++11 新特性的介绍，中文C++11介绍，英文C++11介绍 ，另外C++之父 Bjarne Stroustrup 的关于 C++11 的 FAQ 也是必看的，我也收集了一些关于C++11的资料，供大家查阅，详见本章的 <a href="https://github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial/blob/master/zh/chapter1-Introduction/web-resources.md">资料汇</a></p>

<!-- more -->


<h1>与 C++11 多线程相关的头文件</h1>

<p>C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 <code>&lt;atomic&gt;, &lt;thread&gt;, &lt;mutex&gt;, &lt;condition_variable&gt;</code> 和 <code>&lt;future&gt;</code>。</p>

<ul>
<li><p><code>&lt;atomic&gt;</code>：该头文主要声明了两个类, <code>std::atomic</code> 和 <code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</p></li>
<li><p><code>&lt;thread&gt;</code>：该头文件主要声明了 <code>std::thread</code> 类，另外 <code>std::this_thread</code> 命名空间也在该头文件中。</p></li>
<li><p><code>&lt;mutex&gt;</code>：该头文件主要声明了与互斥量(Mutex)相关的类，包括 <code>std::mutex_*</code> 一系列类，<code>std::lock_guard</code>, <code>std::unique_lock</code>, 以及其他的类型和函数。</p></li>
<li><p><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</p></li>
<li><p><code>&lt;future&gt;</code>：该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</p></li>
</ul>


<h1><code>std::thread</code> &ldquo;Hello world&rdquo;</h1>

<p>下面是一个最简单的使用 std::thread 类的例子</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;iostream&gt; </span><span class="c1">// std::cout</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;   </span><span class="c1">// std::thread</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">thread_task</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;hello thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">thread_task</span><span class="p">);</span>
</span><span class='line'>    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Makefile 如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="nf">all</span><span class="o">:</span><span class="n">Thread</span>
</span><span class='line'>
</span><span class='line'><span class="nv">CC</span><span class="o">=</span>g++
</span><span class='line'><span class="nv">CPPFLAGS</span><span class="o">=</span>-Wall -std<span class="o">=</span>c++11 -ggdb
</span><span class='line'><span class="nv">LDFLAGS</span><span class="o">=</span>-pthread
</span><span class='line'>
</span><span class='line'><span class="nf">Thread</span><span class="o">:</span><span class="n">Thread</span>.<span class="n">o</span>
</span><span class='line'>    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="nf">Thread.o</span><span class="o">:</span><span class="n">Thread</span>.<span class="n">cc</span>
</span><span class='line'>    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -o <span class="nv">$@</span> -c <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nf">.PHONY</span><span class="o">:</span>
</span><span class='line'>    clean
</span><span class='line'>
</span><span class='line'><span class="nf">clean</span><span class="o">:</span>
</span><span class='line'>    rm Thread.o Thread
</span></code></pre></td></tr></table></div></figure>


<p>注意在 Linux GCC4.6 环境下，编译时需要加 -pthread，否则执行时会出现：</p>

<pre><code>$ ./Thread
terminate called after throwing an instance of 'std::system_error'
  what():  Operation not permitted
Aborted (core dumped)
</code></pre>

<p>原因是 GCC 默认没有加载 pthread 库，据说在后续的版本中可以不用在编译时添加 -pthread 选项。
如果 -std=c++11 不被支持，请尝试使用 -std=c++0x 代替并确保GCC已经升级。
更多的有关 C++11 Concurrency 的介绍将在后续的一系列博客中写出，希望自己勤快一点吧 ;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Is Concurrency?]]></title>
    <link href="http://forhappy.github.io/blog/2015/05/16/what-is-concurrency/"/>
    <updated>2015-05-16T22:32:12+08:00</updated>
    <id>http://forhappy.github.io/blog/2015/05/16/what-is-concurrency</id>
    <content type="html"><![CDATA[<h2>1.1 什么是并发</h2>

<p>并发(Concurrency)在我们的现实世界中随处可见，以至于我们常常忽略了它的存在，比方说你在工作（假设你是一名程序员，你的工作就是编程）的时候也可以听听自己喜欢的音乐，并且你的耳朵并不会因为手头的工作而忽略了声音的存在（当然，除非你自己有意的去忽略它，但你还是能够听得见声音，只是你的大脑可能不会去感受音乐的节奏），此时你的大脑既要控制你的双手敲击键盘，也要控制你的耳朵去感受音乐。因此，在一定程度上，你的大脑就在并发地处理不同的事情，并且每个时刻都可能会侧重处理某件事情，比如某个时刻音乐达到高潮并且是你喜欢的旋律，你可能会放慢或者停止手边的工作，但在另外一个时刻你正在编写关键代码，需要全神贯注来避免 Bug 的出现，你可能会把声音调小一点或者干脆摘掉耳机。所以，我们的大脑就在并发地指导我们完成各种任务，或者换一种说法，我们需要处理的任务并发地征用我们的大脑，大脑就相当于计算机的 CPU，而待处理的任务就相当于计算机程序（更确切地说应该是进程或线程等执行实体）。</p>

<p>不过在现实世界中，我们并不会严格定义什么是并发。而在计算机程序世界中，为了编写高性能的代码，我们应该理解什么是并发，并发的基本特性是什么，哪些问题可以使用并发编程来（高效地）解决，哪些情况下又应该尽量避免使用并发编程，我们在使用并发编程时需要注意一些什么问题，本章的将会给大家介绍并发的基本概念，带领大家学习并发编程的基本技巧。</p>

<!-- more -->


<h2>1.2 并发与并行的联系和区别</h2>

<p>与并发相近的另一个概念是并行(Parallel)。和并发所描述的情况一样，并行也是指两个或多个任务被同时执行。但是严格来讲，并发和并行的概念并是不等同的，两者存在很大的差别。下面我们来看看计算机科学家们是怎么区分并发和并行的。</p>

<h3>1.2.1 Erlang 之父 Joe Armstrong 的观点</h3>

<p>Erlang 是一种通用的并行程序设计语言，在并行、分布式和容错等方面表现优异。下面是 Erlang 官方的介绍:</p>

<blockquote><p>Erlang is a programming language used to build massively scalable soft real-time systems with requirements on high availability. Erlang&rsquo;s runtime system has built-in support for concurrency, distribution and fault tolerance.</p></blockquote>

<p>Erlang 的发明者 Joe Armstrong 在他的一篇博文(<a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html">原文链接</a>)中提到如何向一个 5 岁的小孩去介绍并发和并行的区别，并给出了下面一幅图（下图是自己重绘的，<a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html">原图连接</a>）：</p>

<p><img src="https://raw.github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial/master/images/chapter1/concurrent-vs-parallel.png" alt="并发与并行的区别" /></p>

<p>直观来讲，并发是两个等待队列中的人同时去竞争一台咖啡机（当然，人是有理性懂礼貌的动物（也不排除某些很霸道的人插队的可能），两队列中的排队者也可能约定交替使用咖啡机，也可能是大家同时竞争咖啡机，谁先竞争到咖啡机谁使用，不过后一种的方法可能引发冲突，因为两个队列里面排在队列首位的人可能同时使用咖啡机），每个等待者在使用咖啡机之前不仅需要知道排在他前面那个人是否已经使用完了咖啡机，还需知道另一个队列中排在首位的人是否也正准备使用咖啡机；而并行是每个队列拥有自己的咖啡机，两个队列之间并没有竞争的关系，队列中的某个排队者只需等待队列前面的人使用完咖啡机，然后再轮到自己使用咖啡机。</p>

<p>因此，并发意味着多个执行实体（比方说上面例子中的人）可能需要竞争资源（咖啡机），因此就不可避免带来竞争和同步的问题；而并行则是不同的执行实体拥有各自的资源，相互之间可能互不干扰。</p>

<h3>1.2.2. Go 发明者之一 Rob Pike 的观点</h3>

<p>Go 是一门新兴的编程语言，Go 官方对其介绍如下：</p>

<blockquote><p>The Go programming language is an open source project to make programmers more productive.</p>

<p>Go is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multicore and networked machines.</p></blockquote>

<p>Go 的并行机制使其非常容易编写多核和网络应用。Go 语言的并发模型基于 CSP(Communicating sequential processes, 参见维基百科 <a href="http://en.wikipedia.org/wiki/Communicating_Sequential_Processes">CSP</a>)。Go 提供了 goroutines(并发执行), channels(同步和通信), select(多路并发控制) 等特性来支持并发编程。Go 的发明者之一 Rob Pick 在他的一篇讲稿(<a href="http://concur.rspace.googlecode.com/hg/talk/concur.html">Concurrency is not Parallelism(it&rsquo;s better)</a>)中提到：</p>

<blockquote><p><a href="http://concur.rspace.googlecode.com/hg/talk/concur.html#slide-3">Concurrency</a>: Programming as the composition of independently executing processes.</p>

<p><a href="http://concur.rspace.googlecode.com/hg/talk/concur.html#slide-4">Parallelism</a>: Programming as the simultaneous execution of (possibly related) computations.</p></blockquote>

<p>Rob 认为并发是程序本身的一种特性，程序被分为多个可独立执行的部分，而各个可独立执行的片段通过通信手段进行协调（后文会提到），而并行则是程序的计算过程（不同的计算过程可能相关联）同时执行。</p>

<p>Rob Pike 的观点是： 并发是一次处理(dealing with)很多事情，而并行是一次做(doing)很多事情.(注: 英文词汇的表达也很微妙)<a href="http://concur.rspace.googlecode.com/hg/talk/concur.html#slide-5">原文</a>是如下：</p>

<blockquote><p>Concurrency is about dealing with lots of things at once.</p>

<p>Parallelism is about doing lots of things at once.</p></blockquote>

<p>前者是关于程序结构的，而后者是关于程序执行的。Rob 认为：</p>

<blockquote><p>Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.</p></blockquote>

<p>即我们可以利用并发的手段去构建一种解决方案来解决那些有可能被并行处理的问题。</p>

<p>作者在本文中还<a href="http://concur.rspace.googlecode.com/hg/talk/concur.html#slide-7">提到</a>，设计并发程序时应该将程序分为多个执行片段，使得每个片段可以独立执行。不同执行片段通过通信(Communication )来进行协调。因此 Go 的并发模型基于 CSP: C. A. R. Hoare: Communicating Sequential Processes (CACM 1978)</p>

<p>作者后面还给出了一个例子来阐述他的观点，感兴趣的读者可以继续阅读：(<a href="http://concur.rspace.googlecode.com/hg/talk/concur.html">Concurrency is not Parallelism(it&rsquo;s better)</a>)</p>

<h3>1.2.3 Haskell 语言中的并发与并行</h3>

<p>(本小节暂未完成)</p>

<h3>1.2.4 其他观点</h3>

<p>另外，Intel 中文网站的一篇文章(<a href="http://software.intel.com/zh-cn/blogs/2010/11/30/400006465">原文链接</a>)曾这样写道（可能不是很权威，不过可以大致说明并发与并行的区别），</p>

<p>并发（Concurrence）：指两个或两个以上的事件或活动在同一时间间隔内发生。并发的实质是单个物理 CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发可以对有限物理资源强制行使多用户共享以提高效率，如下图所示：</p>

<p><img src="https://raw.github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial/master/images/chapter1/intel-blog-concurrency.png" alt="并发" /></p>

<p>并行（Parallelism）指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行，如下图所示：</p>

<p><img src="https://raw.github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial/master/images/chapter1/intel-blog-parallel.png" alt="并行" /></p>

<p>因此，该文认为并发与并行的区别是：并发是一个处理器同时处理多个任务，而并行多个处理器或者是多核的处理器同时处理多个不同的任务。前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生。</p>

<p>而两者的联系是：并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的。并行性是并发性的特例，而并发性是并行性的扩展（个人不赞同此观点）。</p>

<h3>1.2.5 小节</h3>

<p>本文主要讲了什么是并发以及并发和并行的联系和区别。总得来说，Joe Armstrong 的观点通俗易懂，Rob Pike 有关并发和并行的的观点也很有意思。而关于并发和并行具体的差异，本文最后介绍了一种教科书式的解释。读者可以根据自己的理解来选择认同上述某一种或几种观点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 Tech Salon Session 1: C++11 Main Language Features]]></title>
    <link href="http://forhappy.github.io/blog/2015/05/16/c-plus-plus-11-tech-salon-session-1-c-plus-plus-11-main-language-features/"/>
    <updated>2015-05-16T21:58:43+08:00</updated>
    <id>http://forhappy.github.io/blog/2015/05/16/c-plus-plus-11-tech-salon-session-1-c-plus-plus-11-main-language-features</id>
    <content type="html"><![CDATA[<p>This is the CPP11 tech salon session 1.</p>

<!-- more -->


<h2>背景</h2>

<p>最近在公司内部组织了一系列以 C++11 为主题的技术沙龙, 在准备技术资料的同时, 我对 C++11 的新特性做了初步的整理和归纳, 形成了 C++11 系列文章.</p>

<h2>C++ 进化简史</h2>

<p>众所周知, C++ 最早于1979 年在贝尔实验室诞生, 它的发明者是 Bjarne Stroustrup. 最初的 C++ 只是相对简单的”具备了类特性的 C 语言(C With Classes)”, 但它进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。</p>

<p>1985 年公布的 C++ 语言 1.0 版的内容中又添加了一些重要特征: 例如, 虚函数, 函数重载, 操作符重载, 引用, 常量等。</p>

<p>1989 年推出的 2.0 版 C++ 语言进一步完善了原有的语言特性, 新增的内容包括: 类的保护成员, 多重继承, 对象的初始化与赋值的递归机制, 抽象类, 静态成员函数等。</p>

<p>1993 年的 C++ 语言 3.0 版本是 C++ 语言的进一步完善，其中最重要的新特征是模板(template), 此外解决了多重继承产生的二义性问题和相应的构造函数与析构函数的处理等。</p>

<p>1998 年 C++ 标准(ISO/IEC14882 Standard for the C++ Programming Language)得到了国际标准化组织(ISO)和美国标准化协会(ANSI)的批准, 从而颁布了第一个国际化的 C++ 标准，该标准通常简称 ANSI C++ 或 ISO C++ 98 标准, 这一版本的 C++ 标准引入了命名空间、同时标准模板库(STL)中的容器类、通用算法类和字符串类型等组件的引入也使得 C++ 语言更为实用，C++ 标准委员会当时还规定以后每隔 5 年视情况更新 C++ 标准。</p>

<p>后来 C++ 标准委员会于 2003 年通过了 C++ 标准第二版(ISO/IEC 14882:2003): 该版本是一次技术性修订，对第一版进行了整理, 具体内容包括: 修订错误、减少多义性等，但该版本没有改变语言特性, 通常简称 C++03.</p>

<p>此后几年, 新的标准草案叫做 C++0x(当时 C++ 标准委员会预期新一版的 C++ 标准将会在 2010 年之前发布, 但因为新版本 C++ 标准特性太多, 所以新标准发布时间一度被延期). 终于, 在 2011年 8 月 10 日, 针对 C++0x 标准草案的投票正式结束, C++0x 毫无异议地成为正式国际标准. 先前被临时命名为 C++0x 的草案正式定名为 ISO/IEC 14882:2011, 简称 ISO C++11标准. C++11 标准将取代现行的 C++98 和 C++03 语言标准, 国际标准化组织已经于 2011 年 9 月 1 日出版发布 ISO/IEC 14882:2011.</p>

<p>C++11 标准发布三年后, C++ 标准委员会又于 2014 年发布了 C++14 标准, C++14 相对于C++11 也是一个小版本更新. 下一个 C++ 标准预计将在 2017 年发布, 届时可能被定为 C++17 标准. 下图(选自 Herb Sutter 的个人博客)是 C++ 语言的第一个国际标准 C++98 颁布后至 C++17 标准发布之前整个 C++ 语言体系的演进.
<img src="https://isocpp.org/files/img/wg21-timeline.png" alt="C++ 标准演化" /></p>

<h2>C++11 目标</h2>

<p>C++ 被公认为世界上最复杂的语言之一, 同时 C++ 标准委员会也一直致力于C++语言的改进和推广,  C++11 标准的主要目标包括(但不限于):</p>

<ol>
<li>让 C++ 语言更容易学习和使用, 减少人们的学习成本;</li>
<li>维持向后兼容;</li>
<li>提高性能;</li>
<li>增强程序库的易用性;</li>
<li>更好地适应现代硬件发展.</li>
</ol>


<h2>C++11 语言关键特性介绍</h2>

<h2>auto 关键字及类型自动推导</h2>

<p>auto 关键字在 C++03 以前的标准中是有特定含义的, 它表明一个变量或对象存储周期, 大部分局部变量的默认存储周期都是 auto, 因此这一关键字实际上很少被人提及, 所以 C+11 修正了 auto 关键字的语义.</p>

<p>我们知道, 很多动态类型的语言都提供了类型自动推导的特性, 所谓类型自动推导, 是指在变量初始化的时候不显示地指定变量的类型, 而是由编译器或解释器自动根据初始化表达式的类型来推导变量的类型. C++ 是一门静态语言, 类型的推导交由编译器来完成, 这对于复杂类型对象的声明和定义来说, 编译器帮助我们减轻了很多工作. 我们先来看一些简单的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//index为整形</span>
</span><span class='line'><span class="k">auto</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.1415926</span><span class="p">;</span> <span class="c1">//双精度浮点类型</span>
</span><span class='line'><span class="k">auto</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14f</span><span class="p">;</span> <span class="c1">//单精度浮点类型</span>
</span><span class='line'><span class="k">auto</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>  <span class="c1">//字符串数组类型</span>
</span><span class='line'><span class="k">auto</span> <span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//布尔类型</span>
</span><span class='line'><span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">);</span> <span class="c1">//字符串类型</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们再来看一个稍微复杂一点的例子, 假设我们的程序里面需要一个类型为 <code>std::unordered_multimap&lt;std::string,std::string&gt;</code> 的变量来保存某个单词的多个变体, (注: 所谓单词的变体, 就是由组成该单词的字母经过重新排序后得到一个新单词, 例如 later 存在两个变体单词: alert, alter), 那么定义 <code>words</code> 变量:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">arrayunordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设我们需要已经收集了若干个单词的变体单词, 现在需查询某个单词所有的变体单词, 我们可以使用 <code>std::unordered_multimap.equal_range</code> 返回一个 <code>std::pair&lt;T, T&gt;</code>, 如果我们仍然采用 C++03 的代码, 那么只能写成:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">max_string</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码声明了一个变量 <code>range</code>, 然后给变量 <code>range</code> 赋值:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">range</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">max_string</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种写法非常繁琐, 因为程序员需要清楚地了解 <code>words.equal_range()</code> 返回值的细节, 这在一定程度上加重了开发者的负担.</p>

<p>如果使用 C++11 中的 <code>auto</code> 类型自动推导, 我们可以按照以下的方式写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span> <span class="n">max_string</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器会帮助我们自动推导 <code>range</code> 变量的类型, 从而省去了由程序员自己来声明复杂类型变量的的繁琐工作.</p>

<h2>基于范围的 for 循环</h2>

<p>C++ 03 提供了多种方式的循环控制语句, 如 <code>for</code>, <code>while</code> 以及 <code>do { ... } while</code> 等. 其中 <code>for</code> 循环的用法最为普遍:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">initial</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">increment</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">statement</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于容器遍历来说, 这种方式需要编写一些额外的代码, 比如, 我们首先获取到容器的迭代器, 然后根据迭代器来编写访问容器元素的逻辑. 单纯就容器遍历来说, 这种方式未免过于繁琐, 所以 C++11 提供了一种基于范围的 <code>for</code> 循环, 基本语法如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="nl">range_declaration</span> <span class="p">:</span> <span class="n">range_expression</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">loop_statement</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>range_declaration</code> 声明了一个循环变量, 而 <code>range_expression</code> 是范围表达式, 范围表达式的值可以是一个序列容器, 如数组, <code>std::vector</code>, 也可以是一个关联容器, 如 <code>std::map</code> 和 <code>std::set</code>, 甚至自定义的类型, <code>loop_statement</code> 是遍历逻辑, 因此上述的代码可以理解为, 对于范围表达式中的每一个元素(变量)都执行 <code>loop_statement</code> 的操作. 所以此时代码变得简洁易懂, 我们以一个实际的例子来说明:</p>

<p>在上例中, 我们保存了某个单词出现的所有变体, 如果我们只需要保存某个单词的变体个数, 则可以使用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>假如我们输出每个单词的变体数母 counts, 在不采用 C++11 的情况下需要按照以下方式书写代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span>
</span><span class='line'>     <span class="o">::</span><span class="n">const_iterator</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">counts</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span><span class='line'>     <span class="n">ii</span> <span class="o">!=</span> <span class="n">counts</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">ii</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果采用基于范围的 for 循环, 则代码简洁多了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">count</span><span class="p">:</span> <span class="n">counts</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以我们在书写容器遍历的逻辑时, 采用基于范围的 <code>for</code> 循环的方式来遍历容器可以很大程度地的简化代码. 此外, 基于范围的 <code>for</code> 循环还有另外一个好处: 我们不需要自己去判断边界, 从而减少了产生错误的机会, 因为一旦边界判断有误造成了越界后果往往非常严重.</p>

<h2>多重模板关闭符(结束符) “>>”</h2>

<p>在 C++03 语言标准里, 嵌套模板的关闭符是不允许写在一起的, 中间需要由空白符(空格, 制表符)隔开, 这一限制在 C++11 中被移除了. 例如以下变量声明:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vi</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 C++98( C++03 ) 标准中是不合法的, 因为老旧的编译器会将第一个 <code>&gt;</code>(即 <code>&lt;int&gt;</code> 右边 <code>&gt;</code> 尖括号) 当做模板结束符, 这显然是很不合理的, 但之所以这么设计, 很可能是因为早期的 <code>C++</code> 标准为了降低 <code>C++</code> 编译器实现的复杂度, 故意将多重模板的结束符中间加上空白符, 因为这样一来编译器就可以很容易地将模板结束符( <code>&gt;~&gt;</code> (<code>~</code>此处表示一个空白符))和右移操作符( <code>&gt;&gt;</code> )区分开来. 但是从语法角度来讲,  编译器完全可以识别多重模板结束符和右移操作符, 所以 C++11 标准取消了这一限制, 不过为了代码兼容性, 以前的多重模板结束符仍然适用.</p>

<p>所以现在 <code>std::vector&lt;std::list&lt;int&gt;&gt; vi;</code> 变量声明的方式在 C++11 中是合法的. 但值得注意的是: 如果模板参数中的确包含了右移操作符, 则需要使用小括号显示地将右移操作符和模板结束符区分开来.例如,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">2</span> <span class="o">&gt;&gt;</span> <span class="n">L1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 C++11 中也是不合法的, 需要写成:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用小括号 <code>()</code> 将 <code>n&gt;&gt;2</code> 括起来, 这样一来编译器就能够在多重模板结束符和右移操作符同时存在于一个表达式的情况下正确区分两者的含义.</p>

<h2>nullptr 指针</h2>

<p>NULL 在 C++03 以前的标准中由于存在二义性一直受人诟病(其实C++11标准中也没有明确地给出 NULL 的含义, C++11 标准中定义:</p>

<blockquote><p>The macro NULL is an implementation-defined C++ null pointer constant(support.types))</p></blockquote>

<p>也就是说, <code>NULL</code> 宏与编译器实现有关, 不同的编译器对 <code>NULL</code> 的定义不尽相同, 可能定义如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define NULL (0L)</span>
</span><span class='line'><span class="cp">#define NULL 0</span>
</span><span class='line'><span class="cp">#define NULL ((void *)0)</span>
</span></code></pre></td></tr></table></div></figure>


<p>不同的定义方式对代码的可移植性带来了困难, 例如以下代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// 整形指针参数的函数重载</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// 整形参数的函数重载</span>
</span></code></pre></td></tr></table></div></figure>


<p>若我们采用以下方式调用 <code>f()</code>, 不会出现任何问题,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span> <span class="c1">// 无二义, 调用 void f(int *ptr)</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 无二义, 调用 void f(int)</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是如果将 <code>NULL</code> 作为参数传递给 <code>f()</code>, 即 <code>f(NULL);</code>, 则很有可能出现错误,因为不同编译器对 <code>NULL</code> 的定义不同, 代码变得不可移植, 因此 <code>f(NULL)</code> 具有二义性, 可能调用 <code>void f(int *ptr)</code>, 也可能调用 <code>void f(int)</code>.</p>

<h2>增强的枚举类型</h2>

<p>在 C++03 以前的标准中, <code>enum</code> 枚举类型本质上是整型，它们可以和整型以及其它的枚举类型相比较, 因此代码非常不安全, 另外, 旧式枚举类型的另外一个限制是枚举量被暴露在外层作用域中. 这意味着下面的代码是不能通过编译的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span><span class="n">RED</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
</span><span class='line'><span class="k">enum</span> <span class="n">Feelings</span> <span class="p">{</span><span class="n">EXCITED</span><span class="p">,</span> <span class="n">MOODY</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为 <code>Color</code> 和 <code>Feelings</code> 中的 <code>BLUE</code>( <code>Blue</code>在描述颜色的时候是<code>蓝色</code>, 描述感情的时候表示<code>忧桑</code>)处于同一作用域中, 两者产生了冲突. C++11 引入了强类型的枚举量, 强类型枚举由 <code>enum</code> 和 <code>class</code> 两个关键字定义,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="n">class</span> <span class="n">Color</span> <span class="p">{</span><span class="n">RED</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
</span><span class='line'><span class="k">enum</span> <span class="n">class</span> <span class="n">Feelings</span> <span class="p">{</span><span class="n">EXCITED</span><span class="p">,</span> <span class="n">MOODY</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>class</code> 意味着每一个枚举类型实际上都是不一样的，某一个枚举量不能和其它类型做比较. 另外, 强类型枚举类的每个枚举值作用域被限制在该枚举类中, 消除了 C++03 标准中枚举类型污染外层命名空间的问题.</p>

<h2>统一初始化语法</h2>

<p>C++03 提供多种变量初始化的语法, 不同的初始化行为也不尽相同, 比方说存在一个类 <code>T</code> 定义如下: <code>struct T { int m; }</code>, <code>new T</code> 和 <code>new T()</code> 两种方式是不一样的, 在不同的编译优化级别情况下(如 GCC 的 -O2,-O3), <code>new T</code> 生成的对象的 <code>m</code> 成员有可能是被随机初始化的, 而 <code>new T()</code> 则会被初始化 <code>m</code> 为 0, 此外, C++03 标准在变量初始化方面还存在其他问题, 例如简单类型对象和复杂类型的对象初始化方法不一致. 此外, 某些容器对象不能通过简单类型的数据来初始化, 一个很明显的例子是 <code>std::vector</code> 类型, 如果给定的若干初始值来初始化一个 <code>std::vector</code>, 则需要将这些元素放在数组中, 然后调用 <code>std::vector</code> 的构造函数进行初始化. 类似以下代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">vals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>
</span><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cv</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">vals</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11 中统一了变量初始化语法, 现在我们可以统一使用大括号对不同类型的变量进行初始化. 请看下面的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">{</span><span class="mi">5</span><span class="p">};</span> <span class="c1">//简单类型变量初始化</span>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="o">*</span><span class="mi">2</span><span class="p">};</span> <span class="c1">//原生数组初始化</span>
</span><span class='line'><span class="k">const</span> <span class="n">Point</span> <span class="n">point</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span> <span class="c1">//简单对象初始化</span>
</span><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cv</span><span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">20</span><span class="p">,</span><span class="n">val</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">class</span> <span class="n">Widget</span> <span class="p">{</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>    <span class="c1">// const成员初始化</span>
</span><span class='line'>    <span class="n">Widget</span><span class="p">()</span><span class="o">:</span> <span class="n">data</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span> <span class="p">{}</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// const 指针初始化.</span>
</span><span class='line'><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">new</span> <span class="k">const</span> <span class="kt">float</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'>                     <span class="p">{</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>初始化列表</h2>

<p>C++11 的初始化列表特性是从 C 语言继承过来的，简单来说就是: 结构体或者数组可以使用大括号包含的参数列表来初始化(按照定义的顺序依次初始化)。</p>

<p>C++11 使用模板 <code>std::initializer_list</code> 来实现使用列表初始化这一技术，我们可以使用 <code>std::initializer_list</code> 来给构造函数或者其他函数传递参数。</p>

<p>请看以下例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">simple_list</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="err">“</span><span class="n">U</span><span class="s">&quot;};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面两种初始化的方法在 C++03 及以前的标准中是不合法的, 但是在 C++11 中, 由于大括号包裹的元素列表是可以被转换成初始化列表 <code>std::initializer_list</code> 的, 而初始化列表可以作为参数传递给构造函数, 所以我们可以直接将一个由大括号包裹的列表传递给某个对象的初始化方法中.</p>

<p>例如以下代码, 我们利用 <code>std::vector</code> 模拟了一个简单链表 Simple List: <code>SList</code>, 该链表的一个构造函数签名是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SList</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以, 由我们先前所提到的大括号包裹的元素列表可以被转换成初始化列表 <code>std::initializer_list</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">class</span> <span class="n">SList</span> <span class="p">{</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="n">SList</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">SList</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">){</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">begin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">it</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="o">++</span><span class="n">it</span><span class="p">){</span>
</span><span class='line'>       <span class="n">items_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">ite</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">items_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以我们可以按照一下方法来构造 SList,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">SList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mlist</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>该方法会调用构造函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SList</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">).</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11 引入 <code>std::initializer_list</code> 为我们带来了更多的便利, 我们可以讲 <code>std::initializer_list</code> 作为参数传递给普通(成员)函数, 例如定义了 <code>SList</code> 的 <code>append</code> 函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以按照 <code>append({1, 2, 3, 4, 5});</code> 这样的方式调用 <code>append</code> 函数.</p>

<h2>Lambda 表达式</h2>

<p>在 C++03 中使用标准库的一些算法函数, 比如 <code>std::sort</code> 和 <code>std::find</code>，我们希望能够在算法函数调用的附近定义一个临时函数（又称谓词函数，predicate function）。由于语言本身允许在函数内部定义类，可以考虑使用函数对象，然而这通常既麻烦又冗赘. 因此, C++11 标准中引入了 Lambda 表达式, Lambda 表达式有时候也称为闭包(Clojure), 闭包是函数式编程中最常见的概念之一.</p>

<p>C++11中完整定义 Lambda 表达式如下所述:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">[</span><span class="n">capture_block</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span> <span class="n">mutable</span>
</span><span class='line'><span class="n">exception_specification</span> <span class="o">-&gt;</span> <span class="n">return_type</span>
</span><span class='line'><span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>capture_block</code> 是变量捕获声明, 一般来说可以传值捕获(<code>=</code>), 也可以传引用捕获(<code>&amp;</code>),例如 <code>[x, &amp;y]</code> 说明变量 <code>x</code> 传值捕获, 而 <code>&amp;y</code> 则说明变量 <code>y</code> 传引用捕获; <code>[=, &amp;x]</code> 表示 <code>x</code> 传引用捕获, 剩下的变量则以传值捕获; <code>[&amp;, x]</code> 表示 <code>x</code> 传值捕获, 而其他的值则传引用捕获.</p>

<p><code>parameters</code> 参数是 Lambda 表达式的参数, <code>mutable</code> 是指当 Lambada 表达式对外层的变量以传值捕获时, 我们可以在 Lambda 表达式中修改变量的值(但是修改只限于 Lambda 表达式内部, 被修改的值不能被传递出来, 因此也不会影响外层变量的值). <code>exception_specification</code> 对于异常的一些声明, 例如 <code>noexcept</code> 说明 Lambda 不会抛出异常. Lambda 表达式还可以指定返回值, 但是不存在返回值的时候也可以省略.</p>

<p>根据 Lambda 表达式的定义, 我们还可以简化 Lambda 表达式的写法, 如果 Lambda 表达式不会修改按值捕获的变量, 则可以去掉 <code>mutable</code>, 如果使用默认的异常声明, 则可以去掉 <code>exception_specification</code>, 那么此时可以简化为:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">[</span><span class="n">capture_block</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span>
</span><span class='line'><span class="o">-&gt;</span> <span class="n">return_type</span>
</span><span class='line'><span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 Lambda 表达式没有返回值, 那么可以省略 <code>return_type</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">[</span><span class="n">capture_block</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果Lambda表达式没有参数, 那么它的参数也可以省略:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">[</span><span class="n">capture_block</span><span class="p">]</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后, 捕获声明也可以为空(即不捕获外部变量), 但中括号也不能省略, Lambda 函数体也可以为空, 表示Lambda 函数不做任何操作, 但是花括号不能省略. 所以最简单的Lambda表达式为 auto f = []{}; 此后 可以f() 来调用该Lambda表达式(不做任何操作).</p>

<p>前面介绍了Lambda 表达式的语法, 我们来看看具体的 Lambda表达式:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello”; };</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用 <code>f()</code> 将输出 <code>Hello</code>.</p>

<p>下面的 Lambda 表达式传值捕获外层变量 <code>x</code>, <code>y</code>, 并返回 <code>2x + y</code> 的和.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">auto</span> <span class="n">customAdd</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</span><span class='line'><span class="p">{</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="k">return</span> <span class="n">z</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外, 在成员函数中如果需要用到对象的 <code>this</code> 指针，则必须显式的将 <code>this</code> 传入 Lambda 函数，否则成员函数中的 Lambda 函数无法使用任何该对象的参数或函数。例如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">auto</span> <span class="n">customFunc</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="p">]()</span>
</span><span class='line'><span class="p">{</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">SomePrivateMemberFunction</span><span class="p">();</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模板别名</h2>

<p>C++11 中引入了模板别名概念, 例如我们可以这样来定义模板别名:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">using</span> <span class="n">MyVec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAllocator</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// v 的类型为 std::vector&lt;int, MyAllocator&gt;</span>
</span><span class='line'><span class="n">MyVec</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">using</span> <span class="n">StrArr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//类型为 std::array&lt;std::string, 15&gt;</span>
</span><span class='line'><span class="n">StrArr</span><span class="o">&lt;</span><span class="mi">15</span><span class="o">&gt;</span> <span class="n">sa</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在没有使用模板化的场合下, 模板别名和 <code>typedef</code> 的含义相同, 例如我们可以按照以下两种定义一个整数类形的 <code>Hash</code> 集合:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntHash</span><span class="p">;</span>
</span><span class='line'><span class="n">using</span> <span class="n">IntHash</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>更复杂的类型声明, 以下两条语句声明了类型相同的函数指针:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">CallBackPtr</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="n">using</span> <span class="n">CallBackPtr</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上内容是我们本次分享的主要内容, 我会在下一篇文章中继续分享 C++11 的主题, 包括智能指针, 正则表达式, 多线程与并发, C++11 标准库等内容, 欢迎大家一起交流.</p>
]]></content>
  </entry>
  
</feed>
